<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="始于技术 终于生活"><title>浏览器标签之间通信的几种方式 | Hexo</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浏览器标签之间通信的几种方式</h1><a id="logo" href="/."><span class="defualt">coding</span><span class="vi-color">Master</span></a><p class="description">原谅走过的那些曲折，原来留下的都是真的</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浏览器标签之间通信的几种方式</h1><div class="post-meta">Aug 31, 2019</div><div class="post-content"><h2 id="postmessage"><a href="#postmessage" class="headerlink" title="postmessage"></a>postmessage</h2><p>第一种考虑的是<code>postMessage</code> ，方法可以安全地实现跨源通信  </p>
<h3 id="预备属性值"><a href="#预备属性值" class="headerlink" title="预备属性值"></a>预备属性值</h3><p><code>window.opener</code>返回打开当前窗口的源窗口的引用，如果当前窗口不是由其他窗口打开的，则返回null<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.opener</span><br></pre></td></tr></table></figure></p>
<p><code>window.parent</code>返回当前窗口的父窗口对象，一般用在<code>iframe</code>对嵌入它的父窗口引用上，若无父窗口返回自身引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent</span><br></pre></td></tr></table></figure></p>
<p><code>window.top</code>当前窗口的最顶层窗口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.top</span><br></pre></td></tr></table></figure></p>
<p><code>window.frameElement</code>返回嵌入当前窗口的iframe对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frameElement</span><br></pre></td></tr></table></figure></p>
<p><code>window.frameElement</code> 返回嵌入窗口的元素，如果未嵌入窗口，则返回null<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frameElement</span><br></pre></td></tr></table></figure></p>
<p><code>window.frames</code> 返回当前窗口中所有子窗体的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frames</span><br></pre></td></tr></table></figure></p>
<h3 id="通信方法"><a href="#通信方法" class="headerlink" title="通信方法"></a>通信方法</h3><ol>
<li><p>发送窗口引用目标窗口使用<code>postmessage</code>,目的是用来触发目标窗口<code>message</code>的监听事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">originWindow.postMessage(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>窗口通信接受方使用<code>onMessage</code>  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">originWindow.onmessage = <span class="function">(<span class="params">event</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>messageEvent</code>的值打印如下：<br><img src="20190830192259.jpg" width="100%"> </p>
<h3 id="获取目标窗口常用的方法"><a href="#获取目标窗口常用的方法" class="headerlink" title="获取目标窗口常用的方法"></a>获取目标窗口常用的方法</h3><ol>
<li>引用父窗口<code>window.parent</code></li>
<li>引用打开源窗口<code>window.opener</code></li>
<li>引用打开源窗口<code>window.top</code></li>
<li>监听<code>message</code>事件，回调参数的<code>source</code>字段</li>
<li>直接<code>open</code>新窗口的值</li>
<li><code>window.frames</code>获取子框架集合</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://origin.com</span></span><br><span class="line"><span class="keyword">var</span> targetWindow = <span class="built_in">window</span>.open(<span class="string">'http://target.com'</span>)</span><br><span class="line">targetWindow.postMessage(<span class="string">'origin data'</span>,<span class="string">'http://target.com'</span>)</span><br><span class="line"><span class="comment">// http://target.com</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,(event)=&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span>(event.origin !== <span class="string">'http://origin.com'</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 接受到的信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(event.data) <span class="comment">// origin data</span></span><br><span class="line">  <span class="comment">// 把event.source作为回信对象，并且把event.origin作为targetOrigin</span></span><br><span class="line">  event.source.postMessage(<span class="string">'target data'</span>,event.origin)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><mark>使用注意</mark>:<br>使用<code>postMessage</code>将数据发送到其他窗口时，始终指定精确的目标origin，而不是*；接收消息时候要验证当前消息的<code>source</code>来源。否则可能会导致引起跨站点脚本攻击。</p>
<h2 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h2><p>第二种考虑的是<code>localstorage</code>，之所以用这个是因为无意中发现storage也是可以监听的，这样的话就可以通过监听当前同源的storage实现同源不同标签之间的通信刷新。<br>调用<code>localStorage.setItem()</code>触发事件，但是在当前事件监听页面用此方法是不能触发事件的，<strong>必须在不同的同源标签页面，且两次更新的值不变也不会触发事件</strong>。<br>监听事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onstorage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="built_in">console</span>.log(e)&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, (e) =&gt; <span class="built_in">console</span>.log(e))</span><br></pre></td></tr></table></figure></p>
<p>触发事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(<span class="string">'key'</span>,<span class="string">'value'</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>还有能想到的前端实现通信的方法是使用cookie,本质上和storage是一回事，但是没有监听方法，唯一的可以实现通信的方式就是定时器轮询cookie是否更新，而且cookie也同样受限制于同源种cookie,每次发送请求携带多余的cookie增加通信负担，<strong>是一种比较低效的不推荐的方式</strong>。</p>
<blockquote>
<p>原创内容，欢迎交流转载请注明出处</p>
</blockquote>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>zhangxiao</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/08/31/浏览器标签之间通信的几种方式/">http://aszero.com/2019/08/31/浏览器标签之间通信的几种方式/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>aszero</li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="next" href="/2019/05/31/同步异步和阻塞非阻塞概念/">同步异步和阻塞非阻塞概念</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget widget-info"><div class="widget-info"><a style="text-align:center"><img class="widget-info-photo" src="https://img20.360buyimg.com/ee/jfs/t27454/222/2096395420/282307/5767f3e1/5bf6c424N9b90570a.jpg" style="width:80px;height:80px;border-radius: 100%;"></a><p class="myname">厂长大人</p><p class="slogan">Get Busy Living Or Dying</p></div></div><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/31/浏览器标签之间通信的几种方式/">浏览器标签之间通信的几种方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/31/同步异步和阻塞非阻塞概念/">同步异步和阻塞非阻塞概念</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/14/基于RESTful风格的查询api-接口文档/">基于REST风格的查询api的构思设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/12/垂直横向曝光事件的发生/">垂直横向曝光事件的发生</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/15/移动开发中视觉稿和设备之间单位自适应转化/">移动开发中视觉稿和设备之间单位自适应转化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/03/搭建开发脚手架CLI/">搭建开发脚手架CLI</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/15/dotjs-webpack分模块拼接渲染/">dotjs+webpack分模块拼接渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/27/TS笔记整理/">TS笔记整理(1)-类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/29/前端利用js进行图片压缩/">前端利用js进行图片压缩</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/01/限频节流函数debounce-throttle/">限频节流函数debounce&throttle</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/dotjs/">dotjs</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/h5/">h5</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/ts/">ts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/windows/">windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/joacycode" title="github.com/joacycode" target="_blank">github.com/joacycode</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Hexo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>